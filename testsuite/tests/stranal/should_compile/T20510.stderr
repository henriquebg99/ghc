
==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 51, types: 22, coercions: 0, joins: 2/2}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
lvl = GHC.Types.I# 0#

-- RHS size: {terms: 33, types: 14, coercions: 0, joins: 2/2}
small :: Int -> Int
[LclIdX,
 Arity=1,
 Str=<SP(SL)>,
 Cpr=1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x [Dmd=SP(SL)] :: Int) ->
                 joinrec {
                   go [Occ=LoopBreakerT[2]] :: Int -> Int -> Int
                   [LclId[JoinId(2)],
                    Arity=2,
                    Str=<1P(L)><1P(1L)> {atN->SP(L)},
                    Cpr=1,
                    Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                            WorkFree=True, Expandable=True,
                            Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                            Tmpl= \ (z [Occ=Once2!, Dmd=SP(L)] :: Int)
                                    (ds [Occ=Once1!, Dmd=SP(SL)] :: Int) ->
                                    case ds of { GHC.Types.I# ds [Occ=Once1!, Dmd=SL] ->
                                    case ds of ds {
                                      __DEFAULT ->
                                        case z of { GHC.Types.I# x [Occ=Once1] ->
                                        jump go
                                          (GHC.Types.I# (GHC.Prim.+# x ds))
                                          (GHC.Types.I# (GHC.Prim.-# ds 1#))
                                        };
                                      0# -> GHC.Num.$fNumInt_$c* z x
                                    }
                                    }}]
                   go (z [Occ=Once2!, Dmd=SP(L)] :: Int)
                      (ds [Occ=Once1!, Dmd=SP(SL)] :: Int)
                     = case ds of { GHC.Types.I# ds [Occ=Once1!, Dmd=SL] ->
                       case ds of ds {
                         __DEFAULT ->
                           case z of { GHC.Types.I# x [Occ=Once1] ->
                           jump go
                             (GHC.Types.I# (GHC.Prim.+# x ds))
                             (GHC.Types.I# (GHC.Prim.-# ds 1#))
                           };
                         0# -> GHC.Num.$fNumInt_$c* z x
                       }
                       }; } in
                 jump go lvl x}]
small
  = \ (x [Dmd=SP(SL)] :: Int) ->
      join {
        exit :: Int -> Int
        [LclId[JoinId(1)]]
        exit (z :: Int) = GHC.Num.$fNumInt_$c* z x } in
      joinrec {
        go [Occ=LoopBreaker] :: Int -> Int -> Int
        [LclId[JoinId(2)],
         Arity=2,
         Str=<1P(L)><1P(1L)> {atN->SP(L)},
         Cpr=1,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (z [Occ=Once2!, Dmd=SP(L)] :: Int)
                         (ds [Occ=Once1!, Dmd=SP(SL)] :: Int) ->
                         case ds of { GHC.Types.I# ds [Occ=Once1!, Dmd=SL] ->
                         case ds of ds {
                           __DEFAULT ->
                             case z of { GHC.Types.I# x [Occ=Once1] ->
                             jump go
                               (GHC.Types.I# (GHC.Prim.+# x ds))
                               (GHC.Types.I# (GHC.Prim.-# ds 1#))
                             };
                           0# -> GHC.Num.$fNumInt_$c* z x
                         }
                         }}]
        go (z [Dmd=SP(L)] :: Int) (ds [Dmd=SP(SL)] :: Int)
          = case ds of { GHC.Types.I# ds [Dmd=SL] ->
            case ds of ds {
              __DEFAULT ->
                case z of { GHC.Types.I# x ->
                jump go
                  (GHC.Types.I# (GHC.Prim.+# x ds))
                  (GHC.Types.I# (GHC.Prim.-# ds 1#))
                };
              0# -> jump exit z
            }
            }; } in
      jump go lvl x

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T20510"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T20510.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T20510.$trModule = GHC.Types.Module $trModule $trModule



